<!DOCTYPE html>
<html lang="en">
<head>
     <meta charset="UTF-8">
     <meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <link rel="shortcut icon" href="../source/lang-favicon.png" type="image/x-icon">
     <link rel="stylesheet" href="../source/style.css">
     <link rel="stylesheet" href="../source/prism.css">
     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha512-xh6O/CkQoPOWDdYTDqeRdPCVd1SpvCA9XXcUnZS2FmJNp1coAFzvtCN9BmamE+4aHK8yyUHUSCcJHgXloTyT2A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
     <meta name="description" content="Java 2023 Intermediate Question and Answers for Freshers to Crack the Java Interview">
     <title>Java Intermediate Job Interview Questions</title>
</head>
<body>
     <!--Navigation Bar-->
     <header>
          <nav>
               <div class="menu">
                    <h2><a href="../index.html" class="logo">LangGuides</a></h2>
                    <i class="fa-solid fa-bars" id="open"></i>
                    <i class="fa-solid fa-xmark" id="close"></i>
               </div>
               <ul class="nav-links">
                    <a href="../programming/programming-tutorials.html"><li>Programming</li></a>
                    <a href="../jobinterview/interview-questions.html"><li>Job Interview</li></a>
                    <a href="../biography/biography-stories.html"><li>Biography</li></a>
                    <a href="../successstories/sucesss-stories.html"><li>Success Stories</li></a>
                    
                    <a href="../top10/top10.html"><li>Top 10</li></a>
               </ul>
          </nav>
     </header>

     

     <i class="fa-solid fa-arrow-up" id="up"></i> 

<main> 
<section class="content">
<article>
<h1> </h1>

<h2> </h2>

<ol>
<li><a href="#1">What differentiates an abstract class from an interface in Java?
</a></li>
<li><a href="#2">Elaborate on method overloading and method overriding in Java.
</a></li>
<li><a href="#3">How does the "final" keyword serve its purpose in Java?
</a></li>
<li><a href="#4">Explain the mechanism of exception handling in Java, including the try-catch-finally block.
</a></li>
<li><a href="#5">Enumerate and explain the distinctions between the access modifiers in Java.
</a></li>
<li><a href="#6">How does Java handle multithreading? Define synchronized blocks and methods.
</a></li>
<li><a href="#7">What sets checked exceptions apart from unchecked exceptions in Java?
</a></li>
<li><a href="#8">Contrast the characteristics and use cases of ArrayList and LinkedList in Java.
</a></li>
<li><a href="#9">What distinguishes a HashSet from a TreeSet in Java?
</a></li>
<li><a href="#10">What role does the Java Virtual Machine (JVM) play, and how does it operate?
</a></li>

<li><a href="#11">What is the significance of the "static" keyword in Java?
</a></li>
<li><a href="#12">Define autoboxing and unboxing in Java.
</a></li>
<li><a href="#13">Describe the functioning of garbage collection in Java, including the concept of generations.
</a></li>
<li><a href="#14">Differentiate between equals() and == in Java.
</a></li>
<li><a href="#15">How can you restrict the inheritance of a class in Java?
</a></li>
<li><a href="#16">How does Java implement polymorphism through method overriding?
</a></li>
<li><a href="#17">Elaborate on the concept of generics in Java.
</a></li>
<li><a href="#18">How does Java handle file input/output operations? Describe FileReader and FileWriter.
</a></li>
<li><a href="#19">Explain the concept of reflection in Java.
</a></li>
<li><a href="#20">How does the "assert" keyword contribute to Java?
</a></li>

<li><a href="#21">Contrast shallow copy and deep copy in Java.
</a></li>
<li><a href="#22">Explain the dissimilarities between instance variables and static variables in Java.
</a></li>
<li><a href="#23">What is object-oriented programming (OOP), and how does Java support it?
</a></li>
<li><a href="#24">How does exception propagation work in Java?
</a></li>


      
</ol>

</article>

<article>

<h2 id="1">1.  What differentiates an abstract class from an interface in Java?
</h2>
<p>An abstract class can have both concrete and abstract methods, while an interface can only have abstract methods.
</p>
<p>class has the capability to inherit from a single abstract class, while it can implement multiple interfaces simultaneously.</p>
<p>An abstract class can have instance variables, constructors, and static methods, while an interface cannot have instance variables or constructors and can only have static methods (with Java 8 and later, interfaces can have default and static methods).</p>

<h2 id="2">2.  Elaborate on method overloading and method overriding in Java.
</h2>
<p><strong>Method overloading</strong> in Java allows multiple methods with the same name but different parameters to coexist within a class. It enables the class to provide different ways of performing a similar operation based on the type or number of arguments passed to the method. The compiler determines which overloaded method to invoke based on the arguments provided at compile-time. Overloaded methods must differ in terms of the number or types of their parameters.
</p>
<p><strong>Method overriding</strong>  takes place when a subclass creates its own implementation of a method that already exists in its superclass. The method in the subclass should have the identical name, return type, and parameter list as the method in the superclass.</p> 

<h2 id="3">3.  How does the "final" keyword serve its purpose in Java?
</h2>
<p>In Java, the "final" keyword serves multiple purposes depending on its usage</p>
<p>When applied to a variable, "final" makes it a constant, meaning its value cannot be changed once assigned. This is similar to declaring a constant in other programming languages.</p>
<p>When applied to a method, "final" prevents the method from being overridden by subclasses. This can be useful when you want to ensure that the behavior of a method remains unchanged in all derived classes.
</p>
<p>When applied to a class, "final" prevents the class from being subclassed or extended. It signifies that the class is complete and cannot be inherited.
</p>

<h2 id="4">4.  Explain the mechanism of exception handling in Java, including the try-catch-finally block.
</h2>
<p>Exception handling in Java allows you to deal with runtime errors, also known as exceptions, in a controlled manner. It prevents the abrupt termination of a program and provides an opportunity to gracefully handle exceptional situations. The mechanism involves the use of three main blocks: try, catch, and finally.</p>

<h2 id="5">5. Enumerate and explain the distinctions between the access modifiers in Java.
</h2>
<p>Access modifiers in Java determine the visibility and accessibility of classes, methods, variables, and constructors. There are four access modifiers in Java (Public, Protected, Default, Private).</p>

<h2 id="6">6.  How does Java handle multithreading? Define synchronized blocks and methods.
</h2>
<p>Java provides built-in support for multithreading, allowing multiple threads of execution to run concurrently within a single program. The Java language includes features and libraries to create and manage threads. </p>
 <p>In Java, synchronized blocks and methods are used to provide thread safety by allowing only one thread at a time to access a block of code or a method on an object. The synchronization ensures that the shared data accessed within the synchronized block or method is protected from simultaneous modification by multiple threads.</p>

<h2 id="7">7.  What sets checked exceptions apart from unchecked exceptions in Java?
</h2>
<p><strong>Checked Exceptions:</strong> Checked exceptions are exceptions that must be explicitly declared and handled in the code. These exceptions are checked at compile-time, and the compiler enforces that either the exception is caught and handled using a try-catch block, or the method throws the exception using the "throws" keyword. Examples of checked exceptions include IOException, SQLException, and ClassNotFoundException.
</p>
<p><strong>Unchecked Exceptions:</strong> Unchecked exceptions, also known as runtime exceptions, do not require explicit handling or declaration. These exceptions are not checked at compile-time, and the compiler does not enforce handling them. NullPointerException, ArrayIndexOutOfBoundsException, and IllegalArgumentException are the examples.
</p>


<h2 id="8">8.  Contrast the characteristics and use cases of ArrayList and LinkedList in Java.
</h2>
<p><strong>ArrayList</strong> is backed by an array and provides fast random access to elements. It maintains the order of elements and allows for dynamic resizing. Adding or removing elements from the end of an ArrayList is efficient, but inserting or removing elements from the middle of the list is slower because it requires shifting subsequent elements. ArrayList is suitable when frequent access or modification operations occur at the end of the list or when random access to elements is required.
</p>
<p><strong>LinkedList</strong> is implemented as a doubly-linked list, where each element holds a reference to the previous and next elements. It provides efficient insertion and removal of elements at any position, as it only requires updating the neighboring elements' references. However, accessing elements by index is slower compared to ArrayList because LinkedList has to traverse the list sequentially. LinkedList is suitable when frequent insertion or removal operations occur at arbitrary positions in the list.
</p>




<h2 id="9">9.  What distinguishes a HashSet from a TreeSet in Java?
</h2>
<p><strong>HashSet</strong> stores elements in a hash table, which provides constant-time performance for basic operations such as add, remove, and contains. It does not guarantee the order of elements and allows for one null element. HashSet is suitable when the order of elements is not important, and you need fast access and uniqueness of elements.</p>
<p><strong>TreeSet</strong> stores elements in a balanced binary tree (specifically a Red-Black tree) and maintains them in sorted order. The elements are sorted based on their natural ordering or a custom comparator. TreeSet provides guaranteed log(n) time complexity for basic operations and supports various operations such as range queries. TreeSet is suitable when you need the elements to be sorted and want to perform operations such as finding the smallest or largest element efficiently.</p>



<h2 id="10">10. What role does the Java Virtual Machine (JVM) play, and how does it operate?
</h2>
<p>The Java Virtual Machine (JVM) is a key component of the Java platform. It acts as an execution environment for Java bytecode, which is the compiled form of Java source code. </p>
<p><strong>Bytecode Execution:</strong> The JVM executes Java bytecode, which is a platform-independent intermediate code generated by the Java compiler</p>
<p><strong>Memory Management:</strong> The JVM manages memory dynamically, including allocating and freeing memory for Java objects.</p>
<p><strong>Platform Independence:</strong> The JVM enables platform independence by interpreting or just-in-time (JIT) compiling bytecode into machine-specific instructions at runtime. </p>
<p><strong>Security:</strong> The JVM provides a secure environment for executing Java programs by enforcing various security measures, such as bytecode verification, class loading restrictions, and sandboxing.</p>

<h2 id="11">11.  What is the significance of the "static" keyword in Java?
</h2>
<p>In Java, the "static" keyword is used to declare class-level members that are shared among all instances of the class. </p>
<p><strong>Static Variables:</strong> When a variable is declared as static, it becomes a class variable rather than an instance variable. It is shared by all instances of the class, meaning any modification to the static variable will be reflected in all instances.</p>
<p><strong>Static Methods:</strong>Static Methods are methods that are associated with the class itself rather than with a specific instance of the class. </p>
<p><strong>Static Blocks:</strong> Static blocks are utilized to initialize static variables or carry out any other static initialization tasks.

</p>
<p><strong>Static Nested Classes:</strong> Static nested classes are defined within another class and declared as static. They can be accessed using the outer class name and do not require an instance of the outer class.</p>

<h2 id="12">12.  Define autoboxing and unboxing in Java.
</h2>
<p><strong>Autoboxing:</strong> Autoboxing is the automatic conversion of a primitive type to its corresponding wrapper class. For example, when assigning an int value to an Integer object, autoboxing automatically converts the int to Integer. Autoboxing simplifies the code by eliminating the need for manual conversion between primitive types and wrapper classes.
</p>
<p><strong>Unboxing:</strong> Unboxing is the automatic conversion of a wrapper class object to its corresponding primitive type. For example, when assigning an Integer object to an int variable, unboxing automatically extracts the int value from the Integer object. Unboxing allows you to work with wrapper class objects as if they were primitive types.
</p>



<h2 id="13">13.  Describe the functioning of garbage collection in Java, including the concept of generations.
</h2>
<p>Garbage collection in Java is the automatic process of reclaiming memory occupied by objects that are no longer in use. The JVM manages memory automatically, and the garbage collector is responsible for identifying and releasing memory from objects that are no longer reachable. </p>
<p><strong>Mark and Sweep:</strong> The most common garbage collection algorithm is the mark-and-sweep algorithm. It works by first marking all objects that are reachable from the root of the object graph (typically starting from the main method).</p>
<p><strong>Heap Segmentation (Generational):</strong> The heap memory in Java is divided into multiple segments called generations. Typically, there are three generations: young generation, old generation, and permanent generation (Java 8 and earlier).</p>
<p><strong>Stop-the-World:</strong> During garbage collection, the JVM pauses the execution of all application threads, known as a stop-the-world event. This allows the garbage collector to perform its tasks without interference.</p>

<h2 id="14">14.  Differentiate between equals() and == in Java.
</h2>
<p><strong>equals():</strong> The "equals()" method is defined in the Object class and can be overridden by subclasses. It is used to compare the content or values of objects for equality. By default, the "equals()" method compares object references to determine equality, but it can be overridden to provide custom comparison logic. It is typically used to check if two objects are meaningfully equivalent.</p>
<p><strong>== operator:</strong> The "==" operator compares the object references for equality. It checks if two object references refer to the same memory location, essentially comparing their addresses. It does not consider the content or values of the objects. The "==" operator is commonly used to check if two variables refer to the same object instance.</p>
<pre><code class="language-java">
public class EqualsVsDoubleEqual {
public static void main(String[] args) {
     String str1 = "Hello";
     String str2 = "Hello";
     String str3 = new String("Hello");

     // Using equals() method
     System.out.println(str1.equals(str2)); // true
     System.out.println(str1.equals(str3)); // true

     // Using == operator
     System.out.println(str1 == str2); // true
     System.out.println(str1 == str3); // false
}
}
      
</code></pre>


<h2 id="15">15. How can you restrict the inheritance of a class in Java?
</h2>
<p><strong>Final Class:</strong> When a class is declared as final, it cannot be subclassed. In other words, it cannot be extended by any other class. This is achieved by preventing any further inheritance from the final class. Examples of final classes in Java include the String class and the Math class. To make a class final, use the "final" keyword before the class declaration: <strong>final class ClassName.</strong>
</p>
<p><strong>Final Method:</strong> If a method is declared as final within a class, it cannot be overridden by any subclass. This ensures that the functionality of the method remains constant across all subclasses. To make a method final, use the "final" keyword before the method declaration: <strong>final returnType methodName() { ... }</strong>.
</p>



     
 

<h3 id="16">16. How does Java implement polymorphism through method overriding?
</h3>
<p>Java implements polymorphism through method overriding, which allows a subclass to provide its own implementation of a method defined in its superclass. </p>




<h3 id="17">17. Elaborate on the concept of generics in Java.
</h3>
<p>Generics in Java provide a way to create classes, interfaces, and methods that can work with different data types while providing compile-time type safety. Generics allow you to define classes or methods that are parameterized by one or more types.</p>
<p><strong>Type Parameter:</strong> A type parameter serves as a substitute for a particular type. It is indicated using angle brackets ("&lt; >") and can be any valid Java identifier.
</p>
<p><strong>Generic Class/Interface:</strong> A generic class or interface is one that is parameterized by one or more type parameters. The type parameters are used throughout the class or interface definition. For example, <strong>ArrayList&lt;E&gt;</strong> is a generic class that can hold elements of any type <strong>E</strong>.
</p>
<p><strong>Compile-Time Type Safety:</strong> Generics enable compile-time type checking, ensuring that the code operates on the correct types and preventing type-related errors at runtime. The compiler enforces type constraints and performs type inference.
</p>


<h3 id="18">18. How does Java handle file input/output operations? Describe FileReader and FileWriter.
</h3>
<p>Java provides several classes and APIs for file input/output operations. Two commonly used classes for reading and writing character-oriented data from/to files are FileReader and FileWriter.</p>
<p><strong>FileReader:</strong> The FileReader class is used for reading character data from a file. It extends the InputStreamReader class and provides convenient methods for reading characters and character arrays from a file. It reads the file character by character or in chunks and converts the bytes into characters using the default character encoding of the platform.
</p>
<pre><code class="language-java">
try (FileReader fileReader = new FileReader("input.txt")) {
int character;
while ((character = fileReader.read()) != -1) {
     System.out.print((char) character);
}
} catch (IOException e) {
e.printStackTrace();
}
      
</code></pre>
<p><strong>FileWriter:</strong> The FileWriter class is used for writing character data to a file. It extends the OutputStreamWriter class and provides methods for writing characters and character arrays to a file. FileWriter automatically creates the file if it doesn't exist and overwrites the content if the file already exists.
</p>
<pre><code class="language-java">
try (FileWriter fileWriter = new FileWriter("output.txt")) {
fileWriter.write("Hello, World!");
fileWriter.flush();
} catch (IOException e) {
e.printStackTrace();
}
      
</code></pre>

<h3 id="19">19. Explain the concept of reflection in Java.
</h3>
<p>Reflection is a powerful feature in Java that allows programs to examine or modify the structure, behavior, and properties of classes, interfaces, methods, and fields at runtime. It provides the ability to analyze and manipulate classes and objects dynamically. </p>
<p><strong>Class Inspection:</strong> Reflection enables the inspection of class information such as class name, modifiers, implemented interfaces, constructors, methods, and fields. </p>
<p><strong>Dynamic Instantiation:</strong> Reflection allows dynamic creation of instances of classes at runtime, even if the class is not known at compile time.</p>
<p><strong>Method Invocation:</strong> Reflection provides the ability to invoke methods dynamically at runtime. It allows you to invoke methods by name, access private or inaccessible methods, and modify method parameters.
</p>

<h3 id="20">20. How does the "assert" keyword contribute to Java?
</h3>
<p>The "assert" keyword in Java is used to perform assertions, which are checks that verify certain conditions are true at runtime. Assertions are mainly used for debugging and testing purposes.</p>
<p><strong>Enabling/Disabling Assertions: </strong> By default, assertions are disabled in Java. To enable them, you need to run the Java program with the "-ea" (or "-enableassertions") command-line option. This allows the JVM to execute assertion statements and verify the specified conditions.</p>
<p><strong>Assert Statement:</strong> The "assert" keyword is used in an assert statement to specify a condition that must be true. If the condition evaluates to false at runtime, an AssertionError is thrown.</p>
<p><strong>Debugging and Testing: </strong> Assertions are primarily used during development and testing to validate assumptions and check invariants. </p>


<h3 id="21">21. Contrast shallow copy and deep copy in Java.
</h3>
<p>Shallow copy and deep copy are mechanisms used to duplicate objects in Java, but they differ in how they handle object references.</p>
<p><strong>Shallow copy</strong> creates a new object but copies the references of the original object's fields to the new object. In other words, it creates a new object with copies of the field values, but the field references still point to the same memory locations as the original object. Consequently, modifications made to the fields of the copied object will also impact the original object, and vice versa.</p>
<p><strong>Deep copy</strong> creates a new object and recursively copies all the fields and their referenced objects. It creates independent copies of the fields, including the objects they reference. This means that changes made to the fields of the copied object will not affect the original object, and they can be modified independently.</p>


<h3 id="22">22. Explain the dissimilarities between instance variables and static variables in Java.
</h3>
<p><strong>Instance variables</strong> are declared within a class but outside any method or block. They are also known as non-static variables.  Every instance of a class possesses its own distinct copy of instance variables. These variables are generated when an object of the class is created. Instance variables belong to the object itself, and each object can have different values for its instance variables. Instance variables are accessed using object references.</p>
<p><strong>Static variables, </strong> also known as class variables, Every instance of a class possesses its own distinct copy of instance variables. These variables are generated when an object of the class is created.</p>



<h3 id="23">23. What is object-oriented programming (OOP), and how does Java support it?
</h3>
<p>Object-Oriented Programming (OOP) is a programming paradigm that organizes software design around objects, which represent real-world entities and encapsulate data (attributes) and behavior (methods). OOP promotes concepts such as inheritance, encapsulation, polymorphism, and abstraction.</p>
<p><strong>Classes and Objects:</strong> Java allows you to define classes, which serve as blueprints for creating objects. Objects are instances of classes and represent specific entities.
</p>
<p><strong>Inheritance:</strong> Java supports inheritance, allowing classes to inherit properties and behavior from parent classes. Inheritance promotes code reuse and hierarchy.
</p>
<p><strong>Encapsulation:</strong> Java provides mechanisms like access modifiers (public, private, protected) to encapsulate the internal state of objects, hiding implementation details and exposing only necessary interfaces.
</p>
<p><strong>Polymorphism:</strong> Java supports polymorphism through method overriding and interfaces. Polymorphism allows objects of different classes to be treated as objects of a common superclass or interface, providing flexibility and extensibility.
</p>
<p><strong>Abstraction:</strong> Java supports abstraction through abstract classes and interfaces. Abstraction enables the definition of common interfaces and the hiding of implementation details.
</p>


 



<h3 id="24">24. How does exception propagation work in Java?
</h3>
<p>Exception propagation refers to the process by which an exception is passed from one method to another, and eventually to the calling code, if it is not caught and handled within the current method. </p>
<p><strong>Throwing Exceptions:</strong> When an exceptional situation occurs in a method, it can throw an exception using the "throw" keyword. The exception can be either a built-in exception class or a custom exception class.
</p>
<p><strong>Catching Exceptions:</strong> When a method throws an exception, it should be either caught and handled within the method using a try-catch block or declared in the method signature using the "throws" keyword to propagate the exception to the calling code.</p>
<p><strong>Propagation Up the Call Stack:</strong> If an exception is thrown in a method and not caught locally, it propagates up the call stack to the calling method.</p>
<p><strong>Exception Handling:</strong> The calling code can handle the propagated exception by using try-catch blocks. </p>


</article>

     </section>

</main>

<footer>
     <h3><a href="../index.html" class="logo">LangGuides</a></h3>
     <p>Copyright &#169;	 2023 langguides. All rights reserved</p>
     <a href="../about/privacy.html">Privacy Policy</a>
     <a href="../about/terms-of-use.html">Terms of Use</a>
</footer>

<script src="../source/index.js"></script>
<script src="../source/prism.js"></script>
</body>
</html>